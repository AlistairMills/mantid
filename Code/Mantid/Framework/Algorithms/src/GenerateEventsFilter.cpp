/*WIKI* 

This algorithm is able to generate one or a series of events filters according to user's requirement.  These filters are stored in a [[SplittersWorkspace]] class object, which will be fed into algorithm [[FilterEvents]].  Each filter has an individual value of workspace index. 

This algorithm is one way to generate one filter or a series of filter, while it is designed for general-purpose as much as possible.  Combined with [[FilterEvents]], it will replace 
 * [[FilterByTime]]
 * [[FilterByLogValue]]

Moreover, the time resolution of these two algorithms is microseconds, i.e., the wall time of an (neutron) event.  While the original [[FilterByTime]] and [[FilterByLogValue]] are of the resolution of pulse time.

==== Functionalities ====  
Here are the types of event filters (i.e., [[SplittersWorkspace]]) that can be generated by this algorithm:
* A filter for one time interval.  

* A series of filters for multiple continuous time intervals, which have the same length of period.  Each of them has an individual workspace index associated.  These workspace indices are incremented by 1 from 0 along with their orders in time. 

* A filter containing one or multiple time intervals according to a specified log value.  Any log value of the time that falls into the selected time intervals is equal or within the tolerance of a user specified value. 

* A series filters containing one or multiple time intervals according to specified log values incremented by a constant value.  Any log value of the time that falls into the selected time intervals is equal or within the tolerance of the log value as v_0 + n x delta_v +/- tolerance_v.

==== Parameter: ''Centre'' ====
The input Boolean parameter ''centre'' is for filtering by log value(s).  If option ''centre'' is taken, then for each interval, 
 * starting time = log_time - tolerance_time;
 * stopping time = log_time - tolerance_time;
It is a shift to left.

==== Parameter: ''LogValueTolerance'' and ''LogValueInterval'' ====
These two parameters are used to determine the log value intervals for filtering events. 

Let user-specified minimum log value to be 'min',  LogValueTolerance to be 'tol', and LogValueInterval to be 'delta', then the log value intervals are (min-tol, min-tol+delta), (min-tol+delta, min-tol+2delta), ... 

The default value of LogValueTolerance is LogValueInterval devided by 2. 

==== About how log value is recorded ====
SNS DAS records log values upon its changing.  The frequency of log sampling is significantly faster than change of the log, i.e., sample environment devices.  Therefore, it is reasonable to assume that all the log value changes as step functions.

The option to do interpolation is not supported at this moment.

== Comparison to FilterByLogValue ==
1. If the first log value is within the specified range and the first log time is after run star time,
FilterByLogValue assumes that the log value before the first recorded log time is also within range, and thus
the first splitter starts from the run star time, while GenerateEventFilter tends to be more conservative,
and thus the first splitter will start from the first log time.


*WIKI*/
//----------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------

#include "MantidAlgorithms/GenerateEventsFilter.h"
#include "MantidKernel/System.h"
#include "MantidKernel/ListValidator.h"
#include "MantidAPI/TableRow.h"
#include "MantidAPI/WorkspaceFactory.h"
#include "MantidAPI/WorkspaceProperty.h"
#include "MantidAPI/Column.h"

using namespace Mantid;
using namespace Mantid::Kernel;
using namespace Mantid::API;

using namespace std;

namespace Mantid
{
namespace Algorithms
{
  DECLARE_ALGORITHM(GenerateEventsFilter)

  //----------------------------------------------------------------------------------------------
  /** Constructor
   */
  GenerateEventsFilter::GenerateEventsFilter()
  {
  }
    
  //----------------------------------------------------------------------------------------------
  /** Destructor
   */
  GenerateEventsFilter::~GenerateEventsFilter()
  {
  }
  
  void GenerateEventsFilter::initDocs()
  {
    this->setWikiSummary("Generate one or a set of event filters according to time or specified log's value.");
  }

  //----------------------------------------------------------------------------------------------
  /** Declare input
   */
  void GenerateEventsFilter::init()
  {
    // Input/Output Workspaces
    declareProperty(
      new API::WorkspaceProperty<DataObjects::EventWorkspace>("InputWorkspace", "", Direction::Input),
      "An input event workspace" );

    declareProperty(
          new API::WorkspaceProperty<API::Workspace>("OutputWorkspace", "", Direction::Output),
          "The name to use for the output SplittersWorkspace object, i.e., the filter." );

    declareProperty(
          new API::WorkspaceProperty<API::ITableWorkspace>("InformationWorkspace", "",
                                                           Direction::Output),
          "Optional output for the information of each splitter workspace index");

    declareProperty("FastLog", false, "Fast log will make output workspace to be a maxtrix workspace. ");

    // Time (general) range
    declareProperty("StartTime", "",
        "The start time, in (a) seconds, (b) nanoseconds or (c) percentage of total run time\n"
        "since the start of the run. OR (d) absolute time. \n"
        "Events before this time are filtered out.");

    declareProperty("StopTime", "",
        "The stop time, in (2) seconds, (b) nanoseconds or (c) percentage of total run time\n"
        "since the start of the run. OR (d) absolute time. \n"
        "Events at or after this time are filtered out.");

    // Split by time (only) in steps
    declareProperty("TimeInterval", -1.0,
        "Length of the time splices if filtered in time only.");

    std::vector<std::string> timeoptions;
    timeoptions.push_back("Seconds");
    timeoptions.push_back("Nanoseconds");
    timeoptions.push_back("Percent");
    declareProperty("UnitOfTime", "Seconds", boost::make_shared<Kernel::StringListValidator>(timeoptions),
                    "StartTime, StopTime and DeltaTime can be given in various unit."
                    "The unit can be second or nanosecond from run start time."
                    "They can also be defined as percentage of total run time.");

    // Split by log value (only) in steps
    declareProperty("LogName", "",
        "Name of the sample log to use to filter.\n"
        "For example, the pulse charge is recorded in 'ProtonCharge'.");

    declareProperty("MinimumLogValue", EMPTY_DBL(), "Minimum log value for which to keep events.");

    declareProperty("MaximumLogValue", EMPTY_DBL(), "Maximum log value for which to keep events.");

    declareProperty("LogValueInterval", EMPTY_DBL(),
        "Delta of log value to be sliced into from min log value and max log value.\n"
        "If not given, then only value ");

    std::vector<std::string> filteroptions;
    filteroptions.push_back("Both");
    filteroptions.push_back("Increase");
    filteroptions.push_back("Decrease");
    declareProperty("FilterLogValueByChangingDirection", "Both",
                    boost::make_shared<Kernel::StringListValidator>(filteroptions),
                    "d(log value)/dt can be positive and negative.  They can be put to different splitters.");

    declareProperty("TimeTolerance", 0.0,
                    "Tolerance in time for the event times to keep. "
                    "It is used in the case to filter by single value.");

    vector<string> logboundoptions;
    logboundoptions.push_back("Centre");
    logboundoptions.push_back("Left");
    logboundoptions.push_back("Other");
    auto logvalidator = boost::make_shared<StringListValidator>(logboundoptions);
    declareProperty("LogBoundary", "Centre", logvalidator,
                    "How to treat log values as being measured in the centre of time.");

    declareProperty("LogValueTolerance", EMPTY_DBL(),
        "Tolerance of the log value to be included in filter.  It is used in the case to filter by multiple values.");

    declareProperty("LogValueTimeSections", 1,
        "In one log value interval, it can be further divided into sections in even time slice.");

    // Output workspaces' title and name
    declareProperty("TitleOfSplitters", "",
                    "Title of output splitters workspace and information workspace.");

    // Linear or parallel
    vector<string> processoptions;
    processoptions.push_back("Serial");
    processoptions.push_back("Parallel");
    auto procvalidator = boost::make_shared<StringListValidator>(processoptions);
    declareProperty("UseParallelProcessing", "Serial", procvalidator,
                    "Use multiple cores to generate events filter by log values. \n"
                    "Serial: Use a single core. Good for slow log. \n"
                    "Parallel: Use multiple cores. Appropriate for fast log. ");

    declareProperty("NumberOfThreads", EMPTY_INT(), "Number of threads forced to use in the parallel mode. ");

    return;
  }


  //----------------------------------------------------------------------------------------------
  /** Main execute body
   */
  void GenerateEventsFilter::exec()
  {
    // Process input properties
    processInOutWorkspaces();

    // Get Time
    processInputTime();

    double prog = 0.1;
    progress(prog);

    // Get Log
    std::string logname = this->getProperty("LogName");
    if (logname.empty())
    {
      // a) Set filter by time only
      setFilterByTimeOnly();
    }
    else
    {
      // b) Set filter by time and log
      setFilterByLogValue(logname);
    }

    // Set output workspaces
    if (m_forFastLog)
    {
      if (m_useParallel)
      {
        generateSplittersInMatrixWorkspaceParallel();
      }
      else
      {
        generateSplittersInMatrixWorkspace();
      }
      setProperty("OutputWorkspace", m_filterWS);
    }
    else
    {
      setProperty("OutputWorkspace", m_splitWS);
    }
    setProperty("InformationWorkspace", m_filterInfoWS);

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Process user properties
    */
  void GenerateEventsFilter::processInOutWorkspaces()
  {
    // Input data workspace
    m_dataWS = this->getProperty("InputWorkspace");

    // Output splitter information workspace
    std::string title = getProperty("TitleOfSplitters");
    if (title.size() == 0)
    {
      // Using default
      title = "Splitters";
    }
    m_filterInfoWS = API::WorkspaceFactory::Instance().createTable("TableWorkspace");
    m_filterInfoWS->setTitle(title);
    m_filterInfoWS->addColumn("int", "workspacegroup");
    m_filterInfoWS->addColumn("str", "title");

    // Output Splitters workspace: MatrixWorkspace (optioned) will be generated in last step
    m_forFastLog = getProperty("FastLog");
    if (!m_forFastLog)
    {
      m_splitWS =  boost::shared_ptr<DataObjects::SplittersWorkspace>(new DataObjects::SplittersWorkspace());
      m_splitWS->setTitle(title);
    }

    string algtype = getPropertyValue("UseParallelProcessing");
    if (algtype == "Serial") m_useParallel = false;
    else if (algtype == "Parallel") m_useParallel = true;
    else throw std::runtime_error("Impossible to have 3rd type. ");

    return;
  }


  //----------------------------------------------------------------------------------------------
  /** Process the input for time.  A smart but complicated default rule
    * (1) Input time can be in multiple format: absolute time (ISO), relative time (double)
   */
  void GenerateEventsFilter::processInputTime()
  {
    // Get input
    std::string s_inpt0 = this->getProperty("StartTime");
    std::string s_inptf = this->getProperty("StopTime");

    // Default
    bool defaultstart = (s_inpt0.size() == 0);
    bool defaultstop = (s_inptf.size() == 0);

    // Determine format
    bool instringformat = true;
    if (!defaultstart && s_inpt0.find(':') == std::string::npos)
    {
      // StartTime is not empty and does not contain ":": not ISO
      instringformat = false;
    }
    else if (!defaultstop && s_inptf.find(':') == std::string::npos)
    {
      // StopTime is not empty and does not contain ":": not ISO format
      instringformat = false;
    }

    // Obtain run time range
    DateAndTime runstarttime = m_dataWS->run().startTime();
    /// FIXME Use this simple method may miss the events in the last pulse
    Kernel::TimeSeriesProperty<double>* protonchargelog =
        dynamic_cast<Kernel::TimeSeriesProperty<double> *>(m_dataWS->run().getProperty("proton_charge"));
    Kernel::DateAndTime runendtime = protonchargelog->lastTime();

    // Obtain time unit converter
    std::string timeunit = this->getProperty("UnitOfTime");
    m_timeUnitConvertFactorToNS = -1.0;
    if (timeunit.compare("Seconds") == 0)
    {
      // (second)
      m_timeUnitConvertFactorToNS = 1.0E9;
    }
    else if (timeunit.compare("Nanoseconds") == 0)
    {
      // (nano-seconds)
      m_timeUnitConvertFactorToNS = 1.0;
    }
    else if (timeunit.compare("Percent") == 0)
    {
      // (percent of total run time)
      int64_t runtime_ns = runendtime.totalNanoseconds()-runstarttime.totalNanoseconds();
      double runtimed_ns = static_cast<double>(runtime_ns);
      m_timeUnitConvertFactorToNS = 0.01*runtimed_ns;
    }
    else
    {
      // (Not defined/supported)
      stringstream  errss;
      errss << "TimeType " << timeunit << " is not supported.";
      throw std::runtime_error(errss.str());
    }

    // Set up start time
    if (defaultstart)
    {
      // Default
      m_startTime = runstarttime;
    }
    else if (instringformat)
    {
      // Time is absolute time in ISO format
      m_startTime = DateAndTime(s_inpt0);
    }
    else
    {
      // Relative time in double.
      double inpt0 = atof(s_inpt0.c_str());
      if (inpt0 < 0)
      {
        stringstream errss;
        errss << "Input relative StartTime " << inpt0 << " cannot be negative. ";
        throw std::invalid_argument(errss.str());
      }
      int64_t t0_ns = runstarttime.totalNanoseconds() + static_cast<int64_t>(inpt0*m_timeUnitConvertFactorToNS);
      m_startTime = Kernel::DateAndTime(t0_ns);
    }

    // Set up run stop time
    if (defaultstop)
    {
      // Default
      m_stopTime = runendtime;
    }
    else if (instringformat)
    {
      // Absolute time in ISO format
      m_stopTime = DateAndTime(s_inptf);
    }
    else
    {
      // Relative time in double
      double inptf = atof(s_inptf.c_str());
      int64_t tf_ns = runstarttime.totalNanoseconds()+static_cast<int64_t>(inptf*m_timeUnitConvertFactorToNS);
      m_stopTime = Kernel::DateAndTime(tf_ns);
    }

    // Check start/stop time
    if (m_startTime.totalNanoseconds() >= m_stopTime.totalNanoseconds())
    {
      stringstream errss;
      errss << "Input StartTime " << m_startTime.toISO8601String() << " is equal or later than "
            << "input StopTime " << m_stopTime.toFormattedString();
      throw runtime_error(errss.str());
    }

    g_log.information() << "Filter: StartTime = " << m_startTime << ", StopTime = " << m_stopTime
                        << "; Run start = " << runstarttime.toISO8601String()
                        << ", Run stop = " << runendtime.toISO8601String() << "\n";

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Set splitters by time value / interval only
   */
  void GenerateEventsFilter::setFilterByTimeOnly()
  {
    double timeinterval = this->getProperty("TimeInterval");

    // Progress
    int64_t totaltime = m_stopTime.totalNanoseconds()-m_startTime.totalNanoseconds();
    int64_t timeslot = 0;

    if (timeinterval <= 0.0)
    {
      int wsindex = 0;
      // Default and thus just one interval
#if 0
      Kernel::SplittingInterval ti(m_startTime, m_stopTime, 0);
      m_splitWS->addSplitter(ti);
      API::TableRow row = m_filterInfoWS->appendRow();
      std::stringstream ss;
      ss << "Time Interval From " << m_startTime << " to " << m_stopTime;
      row << wsindex << ss.str();
#else
      std::stringstream ss;
      ss << "Time Interval From " << m_startTime << " to " << m_stopTime;
      addSplitter(m_startTime, m_stopTime, wsindex, ss.str());
#endif
    }
    else
    {
      // Explicitly N time intervals
      int64_t deltatime_ns = static_cast<int64_t>(timeinterval*m_timeUnitConvertFactorToNS);

      int64_t curtime_ns = m_startTime.totalNanoseconds();
      int wsindex = 0;
      while (curtime_ns < m_stopTime.totalNanoseconds())
      {
        // Calculate next.time
        int64_t nexttime_ns = curtime_ns + deltatime_ns;
        if (nexttime_ns > m_stopTime.totalNanoseconds())
          nexttime_ns = m_stopTime.totalNanoseconds();

        // Create splitter and information
        Kernel::DateAndTime t0(curtime_ns);
        Kernel::DateAndTime tf(nexttime_ns);
        std::stringstream ss;
        ss << "Time Interval From " << t0 << " to " << tf;
#if 0

        Kernel::SplittingInterval spiv(t0, tf, wsindex);
        m_splitWS->addSplitter(spiv);

        // c)
        API::TableRow row = m_filterInfoWS->appendRow();

        row << wsindex << ss.str();
#else
        addSplitter(t0, tf, wsindex, ss.str());
#endif

        // Update loop variable
        curtime_ns = nexttime_ns;
        wsindex ++;

        // Update progress
        int64_t newtimeslot = (curtime_ns-m_startTime.totalNanoseconds())*90/totaltime;
        if (newtimeslot > timeslot)
        {
          // There is change and update progress
          timeslot = newtimeslot;
          double prog = 0.1+double(timeslot)/100.0;
          progress(prog);
        }

      } // END-WHILE

    } // END-IF-ELSE

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Generate filters by log values.
    * @param logname :: name of the log to filter with
    */
  void GenerateEventsFilter::setFilterByLogValue(std::string logname)
  {
    // Obtain reference of sample log to filter with
    m_dblLog = dynamic_cast<TimeSeriesProperty<double>* >(m_dataWS->run().getProperty(logname));
    m_intLog = dynamic_cast<TimeSeriesProperty<int>* > (m_dataWS->run().getProperty(logname));
    if (!m_dblLog && !m_intLog)
    {
      stringstream errmsg;
      errmsg << "Log " << logname << " does not exist or is not TimeSeriesProperty in double or integer.";
      throw runtime_error(errmsg.str());
    }

    //  Clear duplicate value
    if (m_dblLog)
      m_dblLog->eliminateDuplicates();
    else
      m_intLog->eliminateDuplicates();

    // Process input properties related to filter with log value
    double minvalue = this->getProperty("MinimumLogValue");
    double maxvalue = this->getProperty("MaximumLogValue");
    double deltaValue = this->getProperty("LogValueInterval");

    // Log value change direction
    std::string filterdirection = getProperty("FilterLogValueByChangingDirection");
    bool filterIncrease;
    bool filterDecrease;
    if (filterdirection.compare("Both") == 0)
    {
      filterIncrease = true;
      filterDecrease = true;
    }
    else if (filterdirection.compare("Increase") == 0)
    {
      filterIncrease = true;
      filterDecrease = false;
    }
    else
    {
      filterIncrease = false;
      filterDecrease = true;
    }

    bool toProcessSingleValueFilter = false;
    if (isEmpty(deltaValue))
    {
      toProcessSingleValueFilter = true;
    }
    else if (deltaValue < 0)
    {
      throw runtime_error("Delta value cannot be negative.");
    }

    // Log boundary
    string logboundary = getProperty("LogBoundary");
    if (logboundary.compare("Centre"))
      m_logAtCentre = true;
    else
      m_logAtCentre = false;

    m_logTimeTolerance = getProperty("TimeTolerance");

    // Generate filters
    if (m_dblLog)
    {
      // Double TimeSeriesProperty log
      // Process min/max
      if (minvalue == EMPTY_DBL())
      {
        minvalue = m_dblLog->minValue();
      }
      if (maxvalue == EMPTY_DBL())
      {
        maxvalue = m_dblLog->maxValue();
      }

      if (minvalue > maxvalue)
      {
        stringstream errmsg;
        errmsg << "Fatal Error: Input minimum log value " << minvalue
               << " is larger than maximum log value " << maxvalue;
        throw runtime_error(errmsg.str());
      }

      // Filter double value log
      if (toProcessSingleValueFilter)
      {
        // Generate a filter for a single log value
        processSingleValueFilter(minvalue, maxvalue, filterIncrease, filterDecrease);
      }
      else
      {
        // Generate filters for a series of log value
        processMultipleValueFilters(minvalue, maxvalue, filterIncrease, filterDecrease);
      }

      // Add splitters
      /// FIXME/TODO : consider of refactor!
      size_t numsplits = m_splitters.size();
      for (size_t i = 0; i < numsplits; ++i)
      {
        SplittingInterval split = m_splitters[i];
        m_splitWS->addSplitter(split);
      }
    }
    else
    {
      // Integer TimeSeriesProperty log
      // Process min/max allowed value
      int minvaluei, maxvaluei;
      if (minvalue == EMPTY_DBL())
      {
        minvaluei = m_intLog->minValue();
        minvalue = static_cast<double>(minvaluei);
      }
      else
        minvaluei = static_cast<int>(minvalue+0.5);

      if (maxvalue == EMPTY_DBL())
      {
        maxvaluei = m_intLog->maxValue();
        maxvalue = static_cast<double>(maxvaluei);
      }
      else
        maxvaluei = static_cast<int>(maxvalue+0.5);

      if (minvalue > maxvalue)
      {
        stringstream errmsg;
        errmsg << "Fatal Error: Input minimum log value " << minvalue
               << " is larger than maximum log value " << maxvalue;
        throw runtime_error(errmsg.str());
      }

      // Split along log
      DateAndTime runendtime = m_dataWS->run().endTime();

      if (m_forFastLog)
      {
        throw runtime_error("Implement ASAP F327.");
      }
      else
      {
        processIntegerValueFilter(minvaluei, maxvaluei, filterIncrease, filterDecrease, runendtime);

        // Add splitters
        /// FIXME/TODO : consider of refactor!
        size_t numsplits = m_splitters.size();
        for (size_t i = 0; i < numsplits; ++i)
        {
          SplittingInterval split = m_splitters[i];
          m_splitWS->addSplitter(split);
        }
      }
    } // ENDIFELSE: Double/Integer Log

    g_log.information() << "Minimum value = " << minvalue <<  ", " << "maximum value = "
                        << maxvalue << ".\n";

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Generate filters by single log value
    * @param minvalue :: minimum value of the allowed log value;
    * @param maxvalue :: maximum value of the allowed log value;
    * @param filterincrease :: if true, log value in the increasing curve should be included;
    * @param filterdecrease :: if true, log value in the decreasing curve should be included;
    */
  void GenerateEventsFilter::processSingleValueFilter(double minvalue, double maxvalue,
                                                      bool filterincrease, bool filterdecrease)
  {
    // 1. Validity & value
    double timetolerance = this->getProperty("TimeTolerance");
    int64_t timetolerance_ns = static_cast<int64_t>(timetolerance*m_timeUnitConvertFactorToNS);

    std::string logboundary = this->getProperty("LogBoundary");
    transform(logboundary.begin(), logboundary.end(), logboundary.begin(), ::tolower);

    // 2. Generate filter
    std::vector<Kernel::SplittingInterval> splitters;
    int wsindex = 0;
    makeFilterByValue(splitters, minvalue, maxvalue, static_cast<double>(timetolerance_ns)*1.0E-9,
        logboundary.compare("centre")==0,
        filterincrease, filterdecrease, m_startTime, m_stopTime, wsindex);

    // 3. Add to output
    for (size_t isp = 0; isp < splitters.size(); isp ++)
    {
      m_splitWS->addSplitter(splitters[isp]);
    }

    // 4. Add information
    API::TableRow row = m_filterInfoWS->appendRow();
    std::stringstream ss;
    ss << "Log " << m_dblLog->name() << " From " << minvalue << " To " << maxvalue << "  Value-change-direction ";
    if (filterincrease && filterdecrease)
    {
      ss << " both ";
    }
    else if (filterincrease)
    {
      ss << " increase";
    }
    else
    {
      ss << " decrease";
    }
    row << 0 << ss.str();

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Generate filters from multiple values
    * @param minvalue :: minimum value of the allowed log value;
    * @param maxvalue :: maximum value of the allowed log value;
    * @param filterincrease :: if true, log value in the increasing curve should be included;
    * @param filterdecrease :: if true, log value in the decreasing curve should be included;
   */
  void GenerateEventsFilter::processMultipleValueFilters(double minvalue, double maxvalue,
                                                         bool filterincrease,
                                                         bool filterdecrease)
  {
    // Read more input
    double valueinterval = this->getProperty("LogValueInterval");
    if (valueinterval <= 0)
      throw std::invalid_argument("Multiple values filter must have LogValueInterval larger than ZERO.");
    double valuetolerance = this->getProperty("LogValueTolerance");

    if (valuetolerance == EMPTY_DBL())
      valuetolerance = 0.5*valueinterval;
    else if (valuetolerance < 0.0)
      throw std::runtime_error("LogValueTolerance cannot be less than zero.");

    // Create log value interval (low/up boundary) list and split information workspace
    std::map<size_t, int> indexwsindexmap;
    std::vector<double> logvalueranges;
    int wsindex = 0;
    size_t index = 0;

    double curvalue = minvalue;
    while (curvalue-valuetolerance < maxvalue)
    {
      indexwsindexmap.insert(std::make_pair(index, wsindex));

      // Log interval/value boundary
      double lowbound = curvalue - valuetolerance ;
      double upbound = curvalue + valueinterval - valuetolerance;
      logvalueranges.push_back(lowbound);
      logvalueranges.push_back(upbound);

      // Workgroup information
      std::stringstream ss;
      ss << "Log " << m_dblLog->name() << " From " << lowbound << " To " << upbound << "  Value-change-direction ";
      if (filterincrease && filterdecrease)
      {
        ss << " both ";
      }
      else if (filterincrease)
      {
        ss << " increase";
      }
      else
      {
        ss << " decrease";
      };
      API::TableRow newrow = m_filterInfoWS->appendRow();
      newrow << wsindex << ss.str();

      curvalue += valueinterval;
      wsindex ++;
      ++index;
    } // ENDWHILE

    // Debug print
    stringstream dbsplitss;
    dbsplitss << "Index map size = " << indexwsindexmap.size() << "\n";
    for (map<size_t, int>::iterator mit = indexwsindexmap.begin();
         mit != indexwsindexmap.end(); ++mit)
    {
      dbsplitss << "Index " << mit->first << ":  WS-group = " << mit->second
              << ". Log value range: " << logvalueranges[mit->first*2] << ", "
              << logvalueranges[mit->first*2+1] << ".\n";
    }
    g_log.debug(dbsplitss.str());

    // Check split interval obtained wehther is with valid size
    if (logvalueranges.size() < 2)
    {
      g_log.warning("There is no log value interval existing.");
      return;
    }

    {
      // Warning information
      double upperboundinterval0 = logvalueranges[1];
      double lowerboundlastinterval = logvalueranges[logvalueranges.size()-2];
      double minlogvalue = m_dblLog->minValue();
      double maxlogvalue = m_dblLog->maxValue();
      if (minlogvalue > upperboundinterval0 || maxlogvalue < lowerboundlastinterval)
      {
        g_log.warning() << "User specifies log interval from " << minvalue-valuetolerance
                        << " to " << maxvalue-valuetolerance << " with interval size = " << valueinterval
                        << "; Log " << m_dblLog->name() << " has range " << minlogvalue << " to " << maxlogvalue
                        << ".  Therefore some workgroup index may not have any splitter." << std::endl;
      }
    }

    // Generate event filters by log value
    Kernel::TimeSplitterType splitters;
    std::string logboundary = this->getProperty("LogBoundary");
    transform(logboundary.begin(), logboundary.end(), logboundary.begin(), ::tolower);

    if (m_useParallel)
    {
      // Make filters in parallel
      makeMultipleFiltersByValuesParallel(indexwsindexmap, logvalueranges,
                                          logboundary.compare("centre") == 0,
                                          filterincrease, filterdecrease, m_startTime, m_stopTime);
    }
    else
    {
      // Make filters in serial
      makeMultipleFiltersByValues(indexwsindexmap, logvalueranges,
                                  logboundary.compare("centre") == 0,
                                  filterincrease, filterdecrease, m_startTime, m_stopTime);
    }

    return;
  }


  //-----------------------------------------------------------------------------------------------
  /**
   * Fill a TimeSplitterType that will filter the events by matching
   * SINGLE log values >= min and < max. Creates SplittingInterval's where
   * times match the log values, and going to index==0.
   *
   * @param filterIncrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param filterDecrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param startTime :: Start time.
   * @param stopTime :: Stop time.
   * @param wsindex :: Workspace index.
   * @param split :: Splitter that will be filled.
   * @param min :: Min value.
   * @param max :: Max value.
   * @param TimeTolerance :: Offset added to times in seconds.
   * @param centre :: Whether the log value time is considered centred or at the beginning.
   */
  void GenerateEventsFilter::makeFilterByValue(TimeSplitterType &split,
                                               double min, double max, double TimeTolerance, bool centre, bool filterIncrease,
                                               bool filterDecrease, DateAndTime startTime, Kernel::DateAndTime stopTime, int wsindex)
  {
    // 1. Do nothing if the log is empty.
    if (m_dblLog->size() == 0)
    {
      g_log.warning() << "There is no entry in this property " << this->name() << "\n";
      return;
    }

    // 2. Do the rest
    bool lastGood = false;
    bool isGood = false;;
    time_duration tol = DateAndTime::durationFromSeconds( TimeTolerance );
    int numgood = 0;
    DateAndTime lastTime, t;
    DateAndTime start, stop;

    size_t progslot = 0;

    for (int i = 0; i < m_dblLog->size(); i ++)
    {
      lastTime = t;
      //The new entry
      t = m_dblLog->nthTime(i);
      double val = m_dblLog->nthValue(i);

      // A good value?
      if (filterIncrease && filterDecrease)
      {
        // a) Including both sides
        isGood = ((val >= min) && (val < max)) && t >= startTime && t <= stopTime;
      }
      else if (filterIncrease)
      {
        if (i == 0)
          isGood = false;
        else
          isGood = ((val >= min) && (val < max)) && t >= startTime && t <= stopTime && val-m_dblLog->nthValue(i-1) > 0;
      }
      else if (filterDecrease)
      {
        if (i == 0)
          isGood = false;
        else
          isGood = ((val >= min) && (val < max)) && t >= startTime && t <= stopTime && val-m_dblLog->nthValue(i-1) < 0;
      }
      else
      {
        g_log.error("Neither increasing nor decreasing is selected.  It is empty!");
      }

      if (isGood)
        numgood++;

      if (isGood != lastGood)
      {
        //We switched from bad to good or good to bad

        if (isGood)
        {
          //Start of a good section
          if (centre)
            start = t - tol;
          else
            start = t;
        }
        else
        {
          //End of the good section
          if (centre)
          {
            stop = t - tol;
          }
          else
          {
            stop = t;
          }
          split.push_back( SplittingInterval(start, stop, wsindex) );

          //Reset the number of good ones, for next time
          numgood = 0;
        }
        lastGood = isGood;
      }

      // Progress bar..
      size_t tmpslot = i*90/m_dblLog->size();
      if (tmpslot > progslot)
      {
        progslot = tmpslot;
        double prog = double(progslot)/100.0+0.1;
        progress(prog);
      }

    } // ENDFOR

    if (numgood > 0)
    {
      //The log ended on "good" so we need to close it using the last time we found
      if (centre)
        stop = t - tol;
      else
        stop = t;
      split.push_back( SplittingInterval(start, stop, wsindex) );
      numgood = 0;
    }

    return;
  }

  //-----------------------------------------------------------------------------------------------
  /** Fill a TimeSplitterType that will filter the events by matching
   * SINGLE log values >= min and < max. Creates SplittingInterval's where
   * times match the log values, and going to index==0.
   *
   * @param split :: Splitter that will be filled.
   * @param indexwsindexmap :: Index.
   * @param logvalueranges ::  A vector of double. Each 2i and 2i+1 pair is one individual log value range.
   * @param centre :: Whether the log value time is considered centred or at the beginning.
   * @param filterIncrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param filterDecrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param startTime :: Start time.
   * @param stopTime :: Stop time.
   */
  void GenerateEventsFilter::makeMultipleFiltersByValues(map<size_t, int> indexwsindexmap,
                                                         vector<double> logvalueranges,
                                                         bool centre, bool filterIncrease, bool filterDecrease,
                                                         DateAndTime startTime, DateAndTime stopTime)
  {
    g_log.notice("Starting method 'makeMultipleFiltersByValues'. ");

    // Return if the log is empty.
    if (m_dblLog->size() == 0)
    {
      g_log.warning() << "There is no entry in this property " << m_dblLog->name() << "\n";
      return;
    }

    // Set up
    double timetolerance = 0.0;
    if (centre)
    {
      timetolerance = this->getProperty("TimeTolerance");
    }
    time_duration tol = DateAndTime::durationFromSeconds( timetolerance );

    // Go through the whole log to set up time intervals
    const Kernel::DateAndTime ZeroTime(0);
    int lastindex = -1;
    int currindex = -1;
    DateAndTime lastTime;
    DateAndTime currTime = ZeroTime;
    DateAndTime start, stop;
    size_t progslot = 0;

    int logsize = m_dblLog->size();
    for (int i = 0; i < logsize; i ++)
    {
      // Initialize status flags and new entry
      bool breakloop = false;
      bool createsplitter = false;

      lastTime = currTime;
      currTime = m_dblLog->nthTime(i);
      double currValue = m_dblLog->nthValue(i);

      // Filter out by time and direction (optional)
      bool intime = false;
      if (currTime < startTime)
      {
        // case i.  Too early, do nothing
        createsplitter = false;
      }
      else if (currTime > stopTime)
      {
        // case ii. Too late.  Put to splitter if half of splitter is done.  But still within range
        breakloop = true;
        stop = currTime;
        if (start.totalNanoseconds() > 0)
        {
          createsplitter = true;
        }
      }
      else
      {
        // case iii. In the range to generate filters
        intime = true;
      }

      // Check log within given time range
      bool newsplitter = false; // Flag to start a new split in this loop

      if (intime)
      {
        // Determine direction
        bool correctdir = true;
        if (filterIncrease && filterDecrease)
        {
          // Both direction is fine
          correctdir = true;
        }
        else
        {
          // Filter out one direction
          int direction = 0;
          if ( m_dblLog->nthValue(i)-m_dblLog->nthValue(i-1) > 0)
            direction = 1;
          else
            direction = -1;
          if (filterIncrease && direction > 0)
            correctdir = true;
          else if (filterDecrease && direction < 0)
            correctdir = true;
          else
            correctdir = false;

          // Condition to generate a Splitter (close parenthesis)
          if (!correctdir && start.totalNanoseconds() > 0)
          {
            stop = currTime;
            createsplitter = true;
          }
        } // END-IF-ELSE: Direction

        // Check this value whether it falls into any range
        if (correctdir)
        {
          size_t index = searchValue(logvalueranges, currValue);

          {
            stringstream dbss;
            dbss << "Flagx257 Examine Log Index " << i << ", Value = " << currValue
                 << ", Data Range Index = " << index << "; "
                 << "Group Index = " << indexwsindexmap[index/2]
                 << " (log value range vector size = " << logvalueranges.size() << ").";
            g_log.debug(dbss.str());
          }

          bool valueWithinMinMax = true;
          if (index > logvalueranges.size())
          {
            // Out of range
            valueWithinMinMax = false;
          }

          if (valueWithinMinMax && index%2 == 0)
          {
            // [Situation] Log value falls in an interval to be selected
            currindex = indexwsindexmap[index/2];

            if (currindex != lastindex && start.totalNanoseconds() == 0)
            {
              // i.   A new region!
              newsplitter = true;
            }
            else if (currindex != lastindex && start.totalNanoseconds() > 0)
            {
              // ii.  Time to close a region and new a region
              stop = currTime;
              createsplitter = true;
              newsplitter = true;
            }
            else if (currindex == lastindex && start.totalNanoseconds() > 0)
            {
              // iii. Still in the same zone
              if (i == logsize-1)
              {
                // Last entry in the log.  Need to flag to close the pair
                stop = currTime;
                createsplitter = true;
                newsplitter = false;
              }
              else
              {
                // Do nothing
                ;
              }
            }
            else
            {
              // iv.  It is impossible
              std::stringstream errmsg;
              double lastvalue =  m_dblLog->nthValue(i-1);
              errmsg << "Impossible to have currindex == lastindex == " << currindex
                     << ", while start is not init.  Log Index = " << i << "\t value = "
                     << currValue << "\t, Index = " << index
                     << " in range " << logvalueranges[index] << ", " << logvalueranges[index+1]
                     << "; Last value = " << lastvalue;

              g_log.error(errmsg.str());
              throw std::runtime_error(errmsg.str());
            }
          } // [In-bound: Inside interval]
          else if (valueWithinMinMax)
          {
            // [Situation] Log value does not fall in any interval to be selected
            currindex = -1;
            if (start.totalNanoseconds() > 0)
            {
              // Close the interval pair if it has been started.
              stop = currTime;
              createsplitter = true;
            }
          } // [In-bound: Between 2 intervals]
          else
          {
            // [Situation] Log value is out of boundary (min/max)
            currindex = -1;
            if (start.totalNanoseconds() > 0)
            {
              // End situation
              stop = currTime;
              createsplitter = true;
            }
          } // [Out-bound]
        } // [CORRECT DIRECTION]
        else
        {
          // Log index i falls out selection due to wrong direction
          currindex = -1;
        }
      } // Neutron event is in specified time range
      else
      {
        // Log index i falls out of selection due to beyond specifed (absolute) time.
        currindex = -1;
      }

      // d) Create Splitter and reset start (time)
      if (createsplitter)
      {
        make_splitter(start, stop, lastindex, tol);
        start = ZeroTime;
      }

      // e) Start new splitter: have to be here due to start cannot be updated before a possible splitter generated
      if (newsplitter)
      {
        start = currTime;
      }

      // f) Break
      if (breakloop)
        break;

      // e) Update loop variable
      lastindex = currindex;

      // f) Progress
      size_t tmpslot = i*90/m_dblLog->size();
      if (tmpslot > progslot)
      {
        progslot = tmpslot;
        double prog = double(progslot)/100.0+0.1;
        progress(prog);
      }

    } // For each log value

    progress(1.0);

    return;
  }


  //-----------------------------------------------------------------------------------------------
  /** Fill a TimeSplitterType that will filter the events by matching
   * SINGLE log values >= min and < max. Creates SplittingInterval's where
   * times match the log values, and going to index==0.
   *
   * @param split :: Splitter that will be filled.
   * @param indexwsindexmap :: Index.
   * @param logvalueranges ::  A vector of double. Each 2i and 2i+1 pair is one individual log value range.
   * @param centre :: Whether the log value time is considered centred or at the beginning.
   * @param filterIncrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param filterDecrease :: As log value increase, and within (min, max), include this range in the filter.
   * @param startTime :: Start time.
   * @param stopTime :: Stop time.
   */
  void GenerateEventsFilter::makeMultipleFiltersByValuesParallel(map<size_t, int> indexwsindexmap,
                                                                 vector<double> logvalueranges,
                                                                 bool centre, bool filterIncrease, bool filterDecrease,
                                                                 DateAndTime startTime, DateAndTime stopTime)
  {
    // Return if the log is empty.
    int logsize = m_dblLog->size();
    if (logsize == 0)
    {
      g_log.warning() << "There is no entry in this property " << m_dblLog->name() << std::endl;
      return;
    }

    // Set up
    double timetolerance = 0.0;
    if (centre)
    {
      timetolerance = this->getProperty("TimeTolerance");
    }
    time_duration tol = DateAndTime::durationFromSeconds( timetolerance );

    // Determine the number of threads to use
    int numThreads = getProperty("NumberOfThreads");
    if (isEmpty(numThreads))
      numThreads = static_cast<int>(PARALLEL_GET_MAX_THREADS);

    // Limit the number of threads.
    numThreads = std::min(numThreads, logsize/8);

    // Determine the istart and iend
    // For split, log should be [0, n], [n, 2n], [2n, 3n], ... as to look into n log values
    std::vector<int> vecStart, vecEnd;
    int partloglength = (logsize-1)/numThreads;
    int extra = (logsize-1)%numThreads;
    for (int i = 0; i < numThreads; ++i)
    {
      int istart = i*partloglength;
      if (i < extra)
        istart += i;
      else
        istart += extra;

      int iend = istart + partloglength;
      if (i < extra)
        ++ iend;

      vecStart.push_back(istart);
      vecEnd.push_back(iend);
    }

    {
      stringstream dbss;
      dbss << "Number of thread = " << numThreads << ", Log Size = " << logsize << "\n";
      for (size_t i = 0; i < vecStart.size(); ++i)
      {
        dbss << "Thread " << i << ": Log range: [" << vecStart[i] << ", " << vecEnd[i] << ") "
                       << "Size = " << vecEnd[i] - vecStart[i] << "\n";
      }
      g_log.information(dbss.str());
    }


    // Create partial vectors
    vecSplitterTimeSet.clear();
    vecGroupIndexSet.clear();
    for (int i = 0; i < numThreads; ++i)
    {
      vector<DateAndTime> tempvectimes;
      tempvectimes.reserve(m_dblLog->size());
      vector<int> tempvecgroup;
      tempvecgroup.reserve(m_dblLog->size());
      vecSplitterTimeSet.push_back(tempvectimes);
      vecGroupIndexSet.push_back(tempvecgroup);
    }

    // Create event filters/splitters in parallel
    PRAGMA_OMP(parallel for schedule(dynamic, 1) )
    for (int i = 0; i < numThreads; ++i)
    {
      PARALLEL_START_INTERUPT_REGION

      int istart = vecStart[i];
      int iend = vecEnd[i];

      makeMultipleFiltersByValuesPartialLog(istart, iend, vecSplitterTimeSet[i], vecGroupIndexSet[i],
                                            indexwsindexmap, logvalueranges, tol,
                                            filterIncrease, filterDecrease, startTime, stopTime);
      PARALLEL_END_INTERUPT_REGION
    }
    PARALLEL_CHECK_INTERUPT_REGION


    // Concatenate splitters on different threads together
    for (int i = 1; i < numThreads; ++i)
    {
      if (vecSplitterTimeSet[i-1].back() == vecSplitterTimeSet[i].front())
      {
        // T_(i).back() = T_(i+1).front()
        if (vecGroupIndexSet[i-1].back() == vecGroupIndexSet[i].front())
        {
          // G_(i).back() = G_(i+1).front(), combine these adjacent 2 splitters
          // Rule out impossible situation
          if (vecGroupIndexSet[i-1].back() == -1) throw runtime_error("It is not possible to have this situation (F01).");

          // Pop back last element
          vecGroupIndexSet[i-1].pop_back();
          DateAndTime newt0 = vecSplitterTimeSet[i-1].front();
          vecSplitterTimeSet[i-1].pop_back();
          DateAndTime origtime = vecSplitterTimeSet[i][0];
          vecSplitterTimeSet[i][0] = newt0;
          g_log.debug() << "Splitter at the end of thread " << i << " is extended from "
                        << origtime << " to " << newt0 << "\n";
        }
        else
        {
          // 2 different and continous spliiter: ideal case without any operation
          ;
        }
      }
      else
      {
        // T_(i).back() != T_(i+1).front(): need to fill the gap in time
        int lastindex = vecGroupIndexSet[i-1].back();
        int firstindex = vecGroupIndexSet[i].front();

        if (lastindex != -1 && firstindex != -1)
        {
          // T_stop < T_start, I_stop != -1, I_start != 1. : Insert a minus-one entry to make it complete
          vecGroupIndexSet[i-1].push_back(-1);
          vecSplitterTimeSet[i-1].push_back(vecSplitterTimeSet[i].front());
        }
        else if (lastindex == -1 && vecGroupIndexSet[i-1].size() == 1)
        {
          // Empty splitter of the thread. Extend this to next
          vecSplitterTimeSet[i-1].back() = vecSplitterTimeSet[i].front();
          g_log.debug() << "Thread = " << i << ", change ending time of " << i-1
                        << " to " << vecSplitterTimeSet[i].front() << "\n";
        }
        else if (firstindex == -1 && vecGroupIndexSet[i].size() == 1)
        {
          // Empty splitter of the thread. Extend last one to this
          vecSplitterTimeSet[i].front() = vecSplitterTimeSet[i-1].back();
          g_log.debug() << "Thread = " << i << ", change starting time to " << vecSplitterTimeSet[i].front()
                        << "\n";
        }
        else
        {
          throw runtime_error("It is not possible to have start or end of filter to be minus-one index. ");
        }
      }
    }

    progress(1.0);

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Make filters by multiple log values of partial log
    */
  void GenerateEventsFilter::makeMultipleFiltersByValuesPartialLog(int istart, int iend,
                                                                   std::vector<Kernel::DateAndTime>& vecSplitTime,
                                                                   std::vector<int>& vecSplitGroup,
                                                                   map<size_t, int> indexwsindexmap,
                                                                   const vector<double>& logvalueranges, time_duration tol,
                                                                   bool filterIncrease, bool filterDecrease,
                                                                   DateAndTime startTime, DateAndTime stopTime)
  {
    // Check
    int logsize = m_dblLog->size();
    if (istart < 0 || iend >= logsize)
      throw runtime_error("Input index of makeMultipleFiltersByValuesPartialLog is out of boundary. ");

    int64_t tol_ns = tol.total_nanoseconds();

    // Define loop control parameters
    const Kernel::DateAndTime ZeroTime(0);
    int lastindex = -1;
    int currindex = -1;
    DateAndTime lastTime;
    DateAndTime currTime = ZeroTime;
    DateAndTime start, stop;
    // size_t progslot = 0; 

    g_log.information() << "Log time coverage (index: " << istart << ", " << iend << ") from "
                        << m_dblLog->nthTime(istart) << ", " << m_dblLog->nthTime(iend) << "\n";

    DateAndTime laststoptime(0);
    for (int i = istart; i <= iend; i ++)
    {
      // Initialize status flags and new entry
      bool breakloop = false;
      bool createsplitter = false;

      lastTime = currTime;
      currTime = m_dblLog->nthTime(i);
      double currValue = m_dblLog->nthValue(i);

      // Filter out by time and direction (optional)
      bool intime = false;
      if (currTime < startTime)
      {
        // case i.  Too early, do nothing
        createsplitter = false;
      }
      else if (currTime > stopTime)
      {
        // case ii. Too late.  Put to splitter if half of splitter is done.  But still within range
        breakloop = true;
        stop = currTime;
        if (start.totalNanoseconds() > 0)
        {
          createsplitter = true;
        }
      }
      else
      {
        // case iii. In the range to generate filters
        intime = true;
      }

      // Check log within given time range
      bool newsplitter = false; // Flag to start a new split in this loop

      if (intime)
      {
        // Determine direction
        bool correctdir = true;
        if (filterIncrease && filterDecrease)
        {
          // Both direction is fine
          correctdir = true;
        }
        else
        {
          // Filter out one direction
          int direction = 0;
          if ( m_dblLog->nthValue(i)-m_dblLog->nthValue(i-1) > 0)
            direction = 1;
          else
            direction = -1;
          if (filterIncrease && direction > 0)
            correctdir = true;
          else if (filterDecrease && direction < 0)
            correctdir = true;
          else
            correctdir = false;

          // Condition to generate a Splitter (close parenthesis)
          if (!correctdir && start.totalNanoseconds() > 0)
          {
            stop = currTime;
            createsplitter = true;
          }
        } // END-IF-ELSE: Direction

        // Check this value whether it falls into any range
        if (correctdir)
        {
          size_t index = searchValue(logvalueranges, currValue);
          {
            stringstream dbss;
            dbss << "DBx257 Examine Log Index " << i << ", Value = " << currValue
                 << ", Data Range Index = " << index << "; "
                 << "Group Index = " << indexwsindexmap[index/2]
                 << " (log value range vector size = " << logvalueranges.size() << ").";
            g_log.debug(dbss.str());
          }

          bool valueWithinMinMax = true;
          if (index > logvalueranges.size())
          {
            // Out of range
            valueWithinMinMax = false;
          }

          if (valueWithinMinMax)
          {
            if (index%2 == 0)
            {
              // [Situation] Falls in the interval
              currindex = indexwsindexmap[index/2];

              if (currindex != lastindex && start.totalNanoseconds() == 0)
              {
                // i.   A new region!
                newsplitter = true;
              }
              else if (currindex != lastindex && start.totalNanoseconds() > 0)
              {
                // ii.  Time to close a region and new a region
                stop = currTime;
                createsplitter = true;
                newsplitter = true;
              }
              else if (currindex == lastindex && start.totalNanoseconds() > 0)
              {
                // iii. Still in the same zone
                if (i == iend)
                {
                  // Last entry in this section of log.  Need to flag to close the pair
                  stop = currTime;
                  createsplitter = true;
                  newsplitter = false;
                }
                else
                {
                  // Do nothing
                  ;
                }
              }
              else
              {
                // iv.  It is impossible
                std::stringstream errmsg;
                double lastvalue =  m_dblLog->nthValue(i-1);
                errmsg << "Impossible to have currindex == lastindex == " << currindex
                       << ", while start is not init.  Log Index = " << i << "\t value = "
                       << currValue << "\t, Index = " << index
                       << " in range " << logvalueranges[index] << ", " << logvalueranges[index+1]
                       << "; Last value = " << lastvalue;

                g_log.error(errmsg.str());
                throw std::runtime_error(errmsg.str());
              }
            } // [In-bound: Inside interval]
            else
            {
              // [Situation] Fall between interval (which is not likley happen)
              currindex = -1;
              if (start.totalNanoseconds() > 0)
              {
                // Close the interval pair if it has been started.
                stop = currTime;
                createsplitter = true;
              }
            } // [In-bound: Between interval]
          }
          else
          {
            // Out of a range.
            currindex = -1;
            if (start.totalNanoseconds() > 0)
            {
              // End situation
              stop = currTime;
              createsplitter = true;
            }
            else
            {
              // No operation required
              ;
            }
          } // [Out-bound]

        } // [CORRECT DIRECTION]
        else
        {
          // Log Index " << i << " Falls out b/c out of wrong direction
          currindex = -1;
        }
      }
      else
      {
        // Log Index " << i << "  Falls Out b/c out of time range... " << std::endl;
        currindex = -1;
      }

      // d) Create Splitter
      if (createsplitter)
      {
        // make_splitter(start, stop, lastindex, tol);
        makeSplitterInVector(vecSplitTime, vecSplitGroup, start, stop, lastindex, tol_ns, laststoptime);

        // reset
        start = ZeroTime;
      }

      // e) Start new splitter: have to be here due to start cannot be updated before a possible splitter generated
      if (newsplitter)
      {
        start = currTime;
      }

      // f) Break
      if (breakloop)
        break;

      // e) Update loop variable
      lastindex = currindex;

    } // For each log value

    // To fill the blanks at the end of log to make last entry of splitter is stop time
    // To make it non-empty
    if (vecSplitTime.size() == 0)
    {
      start = m_dblLog->nthTime(istart);
      stop = m_dblLog->nthTime(iend);
      lastindex = -1;
      makeSplitterInVector(vecSplitTime, vecSplitGroup, start, stop, lastindex, tol_ns, laststoptime);
    }

    return;
  }

  //-----------------------------------------------------------------------------------------------
  /** Generate filters for an integer log
    * @param minvalue :: minimum allowed log value
    * @param maxvalue :: maximum allowed log value
    * @param filterIncrease :: include log value increasing period;
    * @param filterDecrease :: include log value decreasing period
    * @param runend :: end of run date and time
    */
  void GenerateEventsFilter::processIntegerValueFilter(int minvalue, int maxvalue, bool filterIncrease, bool filterDecrease,
                                                       DateAndTime runend)
  {
    // Determine the filter mode and delta
    int delta = 0;
    bool singlevaluemode;
    if (minvalue == maxvalue)
    {
      singlevaluemode = true;
    }
    else
    {
      singlevaluemode = false;

      double deltadbl = getProperty("LogValueInterval");
      if (isEmpty(deltadbl))
      {
        delta = maxvalue-minvalue;
      }
      else
      {
        delta = static_cast<int>(deltadbl+0.5);
      }
      if (delta <= 0)
      {
        stringstream errss;
        errss << "In a non-single value mode, LogValueInterval cannot be 0 or negative for integer.  "
              << "Current input is " << deltadbl << ".";
        throw runtime_error(errss.str());
      }
    }

    // Search along log to generate splitters
    size_t numlogentries = m_intLog->size();
    vector<DateAndTime> times = m_intLog->timesAsVector();
    vector<int> values = m_intLog->valuesAsVector();

    time_duration timetol = DateAndTime::durationFromSeconds( m_logTimeTolerance*m_timeUnitConvertFactorToNS*1.0E-9);

    DateAndTime splitstarttime(0);
    int pregroup = -1;

    g_log.debug() << "Number of integer log entries = " << numlogentries << ".\n";

    for (size_t i = 0; i < numlogentries; ++i)
    {
      int currvalue = values[i];
      int currgroup = -1;

      // Determine whether this log value is allowed and then the ws group it belonged to.
      if (currvalue >= minvalue && currvalue <= maxvalue )
      {
        // Log value is in specified range
        if ((i == 0) || (i >= 1 && ((filterIncrease && values[i] >= values[i-1]) ||
                                    (filterDecrease && values[i] <= values[i-1]))))
        {
          // First entry (regardless direction) and other entries considering change of value
          if (singlevaluemode)
          {
            currgroup = 0;
          }
          else
          {
            currgroup = (currvalue-minvalue)/delta;
          }
        }
      }

      // Make a new splitter if condition is met
      bool statuschanged;
      if (pregroup >= 0 && currgroup < 0)
      {
        // previous log is in allowed region.  but this one is not.  create a splitter
        if (splitstarttime.totalNanoseconds() == 0)
          throw runtime_error("Programming logic error.");
        make_splitter(splitstarttime, times[i], pregroup, timetol);

        splitstarttime = DateAndTime(0);
        statuschanged = true;
      }
      else if (pregroup < 0 && currgroup >= 0)
      {
        // previous log is not allowed, but this one is.  this is the start of a new splitter
        splitstarttime = times[i];
        statuschanged = true;
      }
      else if (currgroup >= 0 && pregroup != currgroup)
      {
        // migrated to a new region
        if (splitstarttime.totalNanoseconds() == 0)
          throw runtime_error("Programming logic error (1).");
        make_splitter(splitstarttime, times[i], pregroup, timetol);

        splitstarttime = times[i];
        statuschanged = true;
      }
      else
      {
        // no need to do anything: status is not changed
        statuschanged = false;
      }

      // Update group/pregroup
      if (statuschanged)
        pregroup = currgroup;

    } // ENDOFLOOP on time series

    // Create the last splitter if existing
    if (pregroup >= 0)
    {
      // Last entry is in an allowed region.
      if (splitstarttime.totalNanoseconds() == 0)
        throw runtime_error("Programming logic error (1).");
      make_splitter(splitstarttime, runend, pregroup, timetol);
    }

    // Write to the information workspace
    // FIXME - Consider to refactor this part with all other methods
    if (singlevaluemode)
    {
      TableRow newrow = m_filterInfoWS->appendRow();
      stringstream message;
      message << m_intLog->name() << " = " << minvalue;
      newrow << 0 << message.str();
    }
    else
    {
      int logvalue = minvalue;
      int wsindex = 0;
      while (logvalue <= maxvalue)
      {
        stringstream message;
        if (logvalue + delta - 1 > logvalue)
          message << m_intLog->name() << " = [" << logvalue << ", " << logvalue+delta-1 << "]";
        else
          message << m_intLog->name() << " = " << logvalue ;

        message << ". Value change direction: ";
        if (filterIncrease && filterDecrease)
          message << "Both.";
        else if (filterIncrease)
          message << "Increasing. ";
        else if (filterDecrease)
          message << "Decreasing. ";

        TableRow newrow = m_filterInfoWS->appendRow();
        newrow << wsindex << message.str();

        ++ wsindex;
        logvalue += delta;
      }
    }

    g_log.notice() << "Integer log " << m_intLog->name() << ": Number of splitters = " << m_splitters.size()
                   << ", Number of split info = " << m_filterInfoWS->rowCount() << ".\n";

    return;
  }


  //----------------------------------------------------------------------------------------------
  /** Do a binary search in the following list
   * Warning: if the vector is not sorted, the error will happen.
   * This algorithm won't guarantee for it
   *
   * @param sorteddata :: Sorted data.
   * @param value :: Value to look up.
   *
   * return:  if value is out of range, then return datarange.size() + 1
   */
  size_t GenerateEventsFilter::searchValue(const std::vector<double>& sorteddata, double value)
  {
    // Case of out-of-boundary
    size_t numdata = sorteddata.size();
    size_t outrange = numdata+1;
    if (numdata == 0) return outrange;
    else if (value < sorteddata.front() || value > sorteddata.back()) return outrange;

    // Binary search
    size_t index = static_cast<size_t>(std::lower_bound(sorteddata.begin(), sorteddata.end(), value)
                                       - sorteddata.begin());
    if (index >= 1)
      -- index;

    return index;

#if 0
    bool found = false;
    size_t start = 0;
    size_t stop = numdata-1;

    while (!found)
    {
      if (start == stop || start+1 == stop)
      {
        // a) Found
        if (value == sorteddata[stop])
        {
          return stop;
        }
        else
        {
          return start;
        }
      }

      size_t mid = (start+stop)/2;
      if (value < sorteddata[mid])
      {
        stop = mid;
      }
      else
      {
        start = mid;
      }
    }

    return 0;
#endif
  }

  //----------------------------------------------------------------------------------------------
  /**
    */
  void GenerateEventsFilter::addSplitter(Kernel::DateAndTime starttime, Kernel::DateAndTime stoptime,
                                         int wsindex, string info)
  {
    if (m_forFastLog)
    {
      // For MatrixWorkspace splitter
      // Start of splitter
      if (m_vecSplitterTime.size() == 0)
      {
        // First splitter
        m_vecSplitterTime.push_back(starttime);
      }
      else if (m_vecSplitterTime.back() < starttime)
      {
        // Splitter to insert has a gap to previous splitter
        m_vecSplitterTime.push_back(starttime);
        m_vecSplitterGroup.push_back(-1);

      }
      else if (m_vecSplitterTime.back() == starttime)
      {
        // Splitter to insert is just behind previous one (no gap): nothing
      }
      else
      {
        // Impossible situation
        throw runtime_error("Logic error. Trying to insert a splitter, whose start time is earlier than last splitter.");
      }
      // Stop of splitter
      m_vecSplitterTime.push_back(stoptime);
      // Group
      m_vecSplitterGroup.push_back(wsindex);
    }
    else
    {
      // For regular Splitter
      Kernel::SplittingInterval spiv(starttime, stoptime, wsindex);
      m_splitWS->addSplitter(spiv);
    }

    // Information
    API::TableRow row = m_filterInfoWS->appendRow();
    row << wsindex << info;

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Generate a new time splitter and add to a list of splitters
    */
  void GenerateEventsFilter::make_splitter(Kernel::DateAndTime start, Kernel::DateAndTime stop, int group, Kernel::time_duration tolerance)
  {
#if 0
    Kernel::SplittingInterval newsplit(start - tolerance, stop - tolerance, group);
    splitters.push_back(newsplit);
#endif

    if (m_forFastLog)
    {
      DateAndTime starttime = start-tolerance;
      DateAndTime stoptime = stop-tolerance;

      // Start time of splitter
      if (m_vecSplitterTime.size() == 0)
      {
        // First value
        m_vecSplitterTime.push_back(starttime);
      }
      else if (m_vecSplitterTime.back() < starttime)
      {
        // Stop time of previous splitter is earlier than start time of this splitter (gap)
        m_vecSplitterTime.push_back(starttime);
        m_vecSplitterGroup.push_back(-1);
      }
      else if (m_vecSplitterTime.back() > starttime)
      {
        // Impossible situation
        throw runtime_error("Impossible situation.");
      }
      else
      {
        // Stop time of previous splitter is the start time of this splitter. Nothing need to do
        ;
      }

      // Stop time of splitter
      m_vecSplitterTime.push_back(stoptime);

      // Group index
      m_vecSplitterGroup.push_back(group);
    }
    else
    {
      // Regular
      Kernel::SplittingInterval newsplit(start - tolerance, stop - tolerance, group);
      m_splitters.push_back(newsplit);
    }

    return;
  }

  //----------------------------------------------------------------------------------------------
  /** Create a splitter and add to the vector of time splitters
    * This method will be called intensively.
    */
  DateAndTime GenerateEventsFilter::makeSplitterInVector(std::vector<Kernel::DateAndTime>& vecSplitTime, std::vector<int>& vecGroupIndex,
                                                         Kernel::DateAndTime start, Kernel::DateAndTime stop, int group,
                                                         int64_t tol_ns, DateAndTime lasttime)
  {
    DateAndTime starttime(start.totalNanoseconds()-tol_ns);
    DateAndTime stoptime(stop.totalNanoseconds()-tol_ns);
    // DateAndTime starttime = start-tolerance;
    // DateAndTime stoptime = stop-tolerance;

    size_t timevecsize = vecSplitTime.size();
    if (timevecsize > 0)
      lasttime = vecSplitTime.back();
    // vecSplitTime.back(),vecSplitTime.back()

    // Start time of splitter
    if (timevecsize == 0)
    {
      // First value
      vecSplitTime.push_back(starttime);
    }
    else if (lasttime < starttime)
    {
      // Stop time of previous splitter is earlier than start time of this splitter (gap)
      vecSplitTime.push_back(starttime);
      vecGroupIndex.push_back(-1);
    }
    else if (lasttime > starttime)
    {
      // Impossible situation
      throw runtime_error("Impossible situation.");
    }
    else
    {
      // Stop time of previous splitter is the start time of this splitter. Nothing need to do
      ;
    }

    // Complete this splitter, i.e., stoptime and group
    // Stop time of splitter
    vecSplitTime.push_back(stoptime);
    // Group index
    vecGroupIndex.push_back(group);

    return stoptime;
  }


  //----------------------------------------------------------------------------------------------
  /** Create a matrix workspace for filter from vector of splitter time and group
    */
  void GenerateEventsFilter::generateSplittersInMatrixWorkspace()
  {
    g_log.information() << "Size of splitter vector: " << m_vecSplitterTime.size() << ", "
                        << m_vecSplitterGroup.size() << "\n";

    size_t sizex = m_vecSplitterTime.size();
    size_t sizey = m_vecSplitterGroup.size();

    if (sizex - sizey != 1)
    {
      throw runtime_error("Logic error on splitter vectors' size. ");
    }

    m_filterWS = API::WorkspaceFactory::Instance().create("Workspace2D", 1, sizex, sizey);
    MantidVec& dataX = m_filterWS->dataX(0);
    for (size_t i = 0; i < sizex; ++i)
    {
      dataX[i] = static_cast<double>(m_vecSplitterTime[i].totalNanoseconds());
    }

    MantidVec& dataY = m_filterWS->dataY(0);
    for (size_t i = 0; i < sizey; ++i)
    {
      dataY[i] = static_cast<double>(m_vecSplitterGroup[i]);
    }

    return;
  }

  void GenerateEventsFilter::generateSplittersInMatrixWorkspaceParallel()
  {
    // Determine size of output matrix workspace
    size_t numtimes = 0;
    size_t numThreads = vecSplitterTimeSet.size();
    for (size_t i = 0; i < numThreads; ++i)
    {
      numtimes += vecGroupIndexSet[i].size();
      g_log.debug() << "[DB] Thread " << i << " have splitter = " << vecGroupIndexSet[i].size() << "\n";
    }
    ++ numtimes;

    size_t sizex = numtimes;
    size_t sizey = numtimes-1;

    m_filterWS = API::WorkspaceFactory::Instance().create("Workspace2D", 1, sizex, sizey);
    MantidVec& dataX = m_filterWS->dataX(0);
    MantidVec& dataY = m_filterWS->dataY(0);

    size_t index = 0;
    for (size_t i = 0; i < numThreads; ++i)
    {
      for (size_t j = 0; j < vecGroupIndexSet[i].size(); ++j)
      {
        dataX[index] = static_cast<double>(vecSplitterTimeSet[i][j].totalNanoseconds());
        dataY[index] = static_cast<double>(vecGroupIndexSet[i][j]);
        ++ index;
      }
    }
    dataX[index] = static_cast<double>(vecSplitterTimeSet.back().back().totalNanoseconds());

    return;
  }

} // namespace Mantid
} // namespace Algorithms
